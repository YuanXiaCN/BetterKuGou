<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>æ¡Œé¢æ­Œè¯</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      -webkit-user-select: none;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Microsoft YaHei', sans-serif;
      background: transparent;
      color: #ffffff;
      overflow: hidden;
      cursor: move;
      -webkit-app-region: drag;
    }

    .lyric-container {
      width: 100%;
      height: 100%;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 20px;
      background: transparent;
      backdrop-filter: none;
      -webkit-backdrop-filter: none;
      border-radius: 12px;
      border: none;
      box-shadow: none;
      transition: all 0.3s ease;
    }

    .lyric-container:hover:not(.locked) {
      background: linear-gradient(135deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 100%);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .lyric-container.locked {
      background: linear-gradient(135deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 100%);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,0.1);
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
    }

    .current-lyric {
      font-size: 24px;
      font-weight: 600;
      text-align: center;
      text-shadow: 2px 2px 8px rgba(0,0,0,1), 1px 1px 4px rgba(0,0,0,0.9);
      margin-bottom: 8px;
      opacity: 0.95;
      transition: all 0.3s ease;
      line-height: 1.4;
      word-wrap: break-word;
      max-width: 100%;
      position: relative;
      overflow: hidden;
    }

    /* å¡æ‹‰OKé€å­—æ•ˆæœæ ·å¼ */
    .karaoke-char {
      display: inline-block;
      color: rgba(255, 255, 255, 0.9);
      text-shadow: 2px 2px 8px rgba(0,0,0,1), 1px 1px 4px rgba(0,0,0,0.9);
      /* ç§»é™¤transitionï¼Œé¿å…åŠ¨ç”»è®¡ç®—æ¶ˆè€—æ€§èƒ½ */
    }

    .karaoke-char.is-space {
      width: 0.25em;
      min-width: 0.25em;
    }

    /* æ­£åœ¨æ’­æ”¾çš„å­—ç¬¦ - ä½¿ç”¨æ¸è¿›å¼å¡«å…… */
    .karaoke-char.singing {
      background: linear-gradient(90deg, #feca57 0%, #feca57 var(--fill-progress, 0%), rgba(255, 255, 255, 0.9) var(--fill-progress, 0%), rgba(255, 255, 255, 0.9) 100%);
      -webkit-background-clip: text;
      background-clip: text;
      -webkit-text-fill-color: transparent;
      text-shadow: 0 0 6px rgba(254, 202, 87, 0.3);
      /* ä½¿ç”¨transformæ›¿ä»£é‡å¤çš„backgroundæ›´æ–°æ¥æå‡æ€§èƒ½ */
      will-change: background-position;
    }

    /* å·²å”±å®Œçš„å­—ç¬¦ */
    .karaoke-char.sung {
      color: #feca57;
      text-shadow: 0 0 8px rgba(254, 202, 87, 0.5), 2px 2px 8px rgba(0,0,0,1);
    }

    /* å½“å‰è¡Œçš„æ•´ä½“é«˜äº® */
    .current-lyric.active-line {
      transform: scale(1.05);
      text-shadow: 
        0 0 10px rgba(254, 202, 87, 0.6),
        2px 2px 8px rgba(0,0,0,1), 
        1px 1px 4px rgba(0,0,0,0.9);
    }

    .next-lyric {
      font-size: 16px;
      font-weight: 400;
      text-align: center;
      color: rgba(255,255,255,0.8);
      text-shadow: 2px 2px 6px rgba(0,0,0,1), 1px 1px 3px rgba(0,0,0,0.8);
      opacity: 0.8;
      transition: all 0.3s ease;
      line-height: 1.3;
      word-wrap: break-word;
      max-width: 100%;
    }

    .song-info {
      font-size: 14px;
      color: rgba(255,255,255,0.7);
      text-align: center;
      margin-bottom: 12px;
      text-shadow: 1px 1px 4px rgba(0,0,0,1), 1px 1px 2px rgba(0,0,0,0.8);
    }

    .no-lyric {
      font-size: 18px;
      color: rgba(255,255,255,0.8);
      text-align: center;
      font-style: italic;
    }

    .control-menu {
      position: absolute;
      top: 10px;
      right: 10px;
      opacity: 0;
      transition: opacity 0.3s ease;
      -webkit-app-region: no-drag;
    }

    .lyric-container:hover:not(.locked) .control-menu {
      opacity: 1;
    }

    .lyric-container.locked .control-menu {
      opacity: 0 !important;
    }

    .menu-btn {
      background: rgba(255,255,255,0.2);
      border: none;
      color: white;
      width: 24px;
      height: 24px;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-left: 4px;
      transition: all 0.2s ease;
      font-size: 12px;
    }

    .menu-btn:hover {
      background: rgba(255,255,255,0.3);
    }

    .controls {
      display: flex;
      gap: 4px;
    }

    /* é”å®šçŠ¶æ€æ ·å¼ */
    .locked {
      cursor: default;
      -webkit-app-region: no-drag;
    }

    .locked .control-menu {
      opacity: 0 !important;
    }

    /* é”å®šæŒ‡ç¤ºå™¨ */
    .lock-indicator {
      position: absolute;
      top: 5px;
      left: 5px;
      color: rgba(255,255,255,0.6);
      font-size: 12px;
      opacity: 0;
      transition: opacity 0.3s ease;
    }

    .locked .lock-indicator {
      opacity: 1;
    }

    /* å­—ä½“å¤§å°å˜ä½“ */
    .size-small .current-lyric { font-size: 18px; }
    .size-small .next-lyric { font-size: 14px; }
    .size-small .song-info { font-size: 12px; }

    .size-medium .current-lyric { font-size: 24px; }
    .size-medium .next-lyric { font-size: 16px; }
    .size-medium .song-info { font-size: 14px; }

    .size-large .current-lyric { font-size: 32px; }
    .size-large .next-lyric { font-size: 20px; }
    .size-large .song-info { font-size: 16px; }

    /* ä¸»é¢˜æ ·å¼ */
    .theme-classic {
      background: linear-gradient(135deg, rgba(0,0,0,0.8) 0%, rgba(0,0,0,0.6) 100%);
      color: #ffffff;
    }

    .theme-gradient {
      background: linear-gradient(135deg, rgba(102,126,234,0.8) 0%, rgba(118,75,162,0.8) 100%);
      color: #ffffff;
    }

    .theme-minimal {
      background: rgba(0,0,0,0.5);
      color: #ffffff;
      border: none;
    }

    /* åŠ¨ç”»æ•ˆæœ */
    @keyframes lyricFadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }
      to {
        opacity: 1;
        transform: translateY(0);
      }
    }

    .lyric-change .current-lyric {
      animation: lyricFadeIn 0.5s ease-out;
    }
  </style>
</head>
<body>
  <div class="lyric-container" id="lyricContainer">
    <div class="lock-indicator">ğŸ”’</div>
    <div class="control-menu">
      <div class="controls">
        <button class="menu-btn" id="sizeBtn" title="å­—ä½“å¤§å°">A</button>
        <button class="menu-btn" id="themeBtn" title="ä¸»é¢˜">ğŸ¨</button>
        <button class="menu-btn" id="closeBtn" title="å…³é—­">âœ•</button>
      </div>
    </div>
    
    <div class="song-info" id="songInfo">æš‚æ— æ’­æ”¾</div>
    <div class="current-lyric" id="currentLyric">è¯·æ’­æ”¾éŸ³ä¹ä»¥æ˜¾ç¤ºæ­Œè¯</div>
    <div class="next-lyric" id="nextLyric"></div>
  </div>

  <script>
    const { ipcRenderer } = require('electron')
    
    // çŠ¶æ€ç®¡ç†
    let isLocked = false
    let currentSize = 'medium' // small, medium, large
    let currentTheme = 'classic' // classic, gradient, minimal
    let currentLyrics = []
    let currentTime = 0
    let currentSong = null
    
    // æ€§èƒ½ä¼˜åŒ–ç›¸å…³
    let lastUpdateTime = 0
    let updateRAFId = null
    let currentLyricIndex = -1
    let lastRenderedHTML = ''
    let isDOMReady = false
    let cachedCharElements = null
    let lastProcessedWordIndex = -1
    let karaokeUpdateCache = new Map()

    // DOM å…ƒç´ 
    const container = document.getElementById('lyricContainer')
    const songInfo = document.getElementById('songInfo')
    const currentLyric = document.getElementById('currentLyric')
    const nextLyric = document.getElementById('nextLyric')
    const sizeBtn = document.getElementById('sizeBtn')
    const themeBtn = document.getElementById('themeBtn')
    const closeBtn = document.getElementById('closeBtn')

    // åˆå§‹åŒ–
    function init() {
      // è®¾ç½®åˆå§‹æ ·å¼
      updateSize()
      updateTheme()
      
      // ç»‘å®šäº‹ä»¶
      sizeBtn.addEventListener('click', cycleSize)
      themeBtn.addEventListener('click', cycleTheme)
      closeBtn.addEventListener('click', closeLyric)

      // ç›‘å¬ä¸»è¿›ç¨‹æ¶ˆæ¯
      ipcRenderer.on('desktop-lyric:song-update', (event, song) => {
        updateSongInfo(song)
      })

      ipcRenderer.on('desktop-lyric:lyric-update', (event, lyrics) => {
        updateLyrics(lyrics)
      })

      ipcRenderer.on('desktop-lyric:time-update', (event, time) => {
        // ä½¿ç”¨requestAnimationFrameè¿›è¡Œæ€§èƒ½ä¼˜åŒ–
        if (updateRAFId) {
          cancelAnimationFrame(updateRAFId)
        }
        updateRAFId = requestAnimationFrame(() => {
          updateCurrentTime(time)
        })
      })

      ipcRenderer.on('desktop-lyric:settings-update', (event, settings) => {
        if (settings.fontSize) currentSize = settings.fontSize
        if (settings.theme) currentTheme = settings.theme
        if (typeof settings.locked === 'boolean') isLocked = settings.locked
        
        updateSize()
        updateTheme()
        updateLockState()
      })

      ipcRenderer.on('desktop-lyric:lock-changed', (event, locked) => {
        isLocked = locked
        updateLockState()
      })

      console.log('æ¡Œé¢æ­Œè¯çª—å£å·²åˆå§‹åŒ–')
    }

    function updateLockState() {
      if (isLocked) {
        container.classList.add('locked')
        document.body.classList.add('locked')
      } else {
        container.classList.remove('locked')
        document.body.classList.remove('locked')
      }
    }

    // å¾ªç¯åˆ‡æ¢å­—ä½“å¤§å°
    function cycleSize() {
      const sizes = ['small', 'medium', 'large']
      const currentIndex = sizes.indexOf(currentSize)
      currentSize = sizes[(currentIndex + 1) % sizes.length]
      updateSize()
      ipcRenderer.send('desktop-lyric:size-changed', currentSize)
    }

    function updateSize() {
      container.className = container.className.replace(/size-\w+/g, '')
      container.classList.add(`size-${currentSize}`)
    }

    // å¾ªç¯åˆ‡æ¢ä¸»é¢˜
    function cycleTheme() {
      const themes = ['classic', 'gradient', 'minimal']
      const currentIndex = themes.indexOf(currentTheme)
      currentTheme = themes[(currentIndex + 1) % themes.length]
      updateTheme()
      ipcRenderer.send('desktop-lyric:theme-changed', currentTheme)
    }

    function updateTheme() {
      container.className = container.className.replace(/theme-\w+/g, '')
      container.classList.add(`theme-${currentTheme}`)
    }

    // å…³é—­æ­Œè¯çª—å£
    function closeLyric() {
      ipcRenderer.send('desktop-lyric:close')
    }

    // æ›´æ–°æ­Œæ›²ä¿¡æ¯
    function updateSongInfo(song) {
      currentSong = song
      if (song && song.title) {
        songInfo.textContent = `${song.title} - ${song.artist || 'æœªçŸ¥æ­Œæ‰‹'}`
      } else {
        songInfo.textContent = 'æš‚æ— æ’­æ”¾'
      }
    }

    // æ›´æ–°æ­Œè¯
    function updateLyrics(lyrics) {
      console.log('æ¡Œé¢æ­Œè¯æ¥æ”¶åˆ°æ•°æ®:', lyrics ? lyrics.length : 0, 'è¡Œ')
      if (lyrics && lyrics.length > 0) {
        console.log('å‰3è¡Œæ­Œè¯:', lyrics.slice(0, 3))
      }
      
      currentLyrics = lyrics || []
      updateCurrentLyric()
    }

    // æ›´æ–°å½“å‰æ—¶é—´
    function updateCurrentTime(time) {
      // æ›´ä¸¥æ ¼çš„é˜²æŠ–ï¼šå‡å°‘æ›´æ–°é¢‘ç‡ï¼Œæ¯50msæœ€å¤šæ›´æ–°ä¸€æ¬¡ï¼ˆ20FPSè¶³å¤Ÿæµç•…ï¼‰
      const now = performance.now()
      if (now - lastUpdateTime < 50) {
        return
      }
      lastUpdateTime = now
      
      currentTime = time
      updateCurrentLyric()
    }

    // æ£€æµ‹æ­Œè¯æ˜¯å¦ä¸ºä¸­æ–‡
    function isChinese(text) {
      if (!text) return false
      return /[\u4e00-\u9fff]/.test(text)
    }

    // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„æ­Œè¯
    function updateCurrentLyric() {      
      if (!currentLyrics || currentLyrics.length === 0) {
        const fallbackText = currentSong ? 'æš‚æ— æ­Œè¯' : 'è¯·æ’­æ”¾éŸ³ä¹ä»¥æ˜¾ç¤ºæ­Œè¯'
        if (currentLyric.textContent !== fallbackText) {
          currentLyric.textContent = fallbackText
          nextLyric.textContent = ''
        }
        return
      }

      let newCurrentIndex = -1
      let nextIndex = -1

      // æ‰¾åˆ°å½“å‰æ—¶é—´å¯¹åº”çš„æ­Œè¯
      for (let i = 0; i < currentLyrics.length; i++) {
        if (currentTime >= currentLyrics[i].time) {
          newCurrentIndex = i
        } else {
          nextIndex = i
          break
        }
      }

      let nextText = ''

      if (newCurrentIndex >= 0) {
        const currentLine = currentLyrics[newCurrentIndex]
        
        // åªåœ¨æ­Œè¯è¡Œå‘ç”Ÿå˜åŒ–æ—¶æ‰é‡æ–°æ¸²æŸ“DOMç»“æ„
        if (newCurrentIndex !== currentLyricIndex) {
          console.log('ğŸµ åˆ‡æ¢åˆ°æ–°æ­Œè¯è¡Œ:', newCurrentIndex, currentLine.text)
          currentLyricIndex = newCurrentIndex
          
          // æ£€æŸ¥æ˜¯å¦æ˜¯KRCæ ¼å¼ï¼ˆæ”¯æŒå¡æ‹‰OKæ•ˆæœï¼‰
          if (currentLine.isKrc && currentLine.words && currentLine.words.length > 0) {
            // æ¸²æŸ“å¡æ‹‰OKæ•ˆæœDOMç»“æ„ï¼ˆåªåœ¨åˆ‡æ¢æ—¶ï¼‰
            renderKaraokeStructure(currentLine)
          } else {
            // æ™®é€šæ­Œè¯æ˜¾ç¤º
            renderNormalLyric(currentLine.text || 'â™ª', currentLine)
          }
        } else if (currentLine.isKrc && currentLine.words && currentLine.words.length > 0) {
          // åŒä¸€è¡Œæ­Œè¯ï¼Œåªæ›´æ–°å¡æ‹‰OKè¿›åº¦ï¼ˆé«˜æ€§èƒ½ï¼‰
          updateKaraokeProgress(currentLine, currentTime)
        }
        
        // è®¾ç½®ä¸‹ä¸€è¡Œæ­Œè¯
        if (nextIndex >= 0) {
          nextText = currentLyrics[nextIndex].text || ''
        } else if (currentLine.translation) {
          nextText = currentLine.translation
        }
      } else {
        if (currentLyric.innerHTML !== 'â™ª') {
          currentLyric.innerHTML = 'â™ª'
          currentLyricIndex = -1
        }
      }
      
      // åªåœ¨æ–‡æœ¬å‘ç”Ÿå˜åŒ–æ—¶æ›´æ–°ä¸‹ä¸€è¡Œæ­Œè¯
      if (nextLyric.textContent !== nextText) {
        nextLyric.textContent = nextText
      }
    }

    // æ¸²æŸ“å¡æ‹‰OK DOMç»“æ„ï¼ˆåªåœ¨æ­Œè¯è¡Œå˜åŒ–æ—¶è°ƒç”¨ï¼‰
    function renderKaraokeStructure(lyricLine) {
      const words = lyricLine.words || []
      let html = ''
      
      console.log('ğŸµ é‡å»ºå¡æ‹‰OK DOMç»“æ„:', words.length, 'ä¸ªå•è¯')
      
      for (let i = 0; i < words.length; i++) {
        const word = words[i]
        const wordText = word.word || word.text
        
        // ä¸ºæ¯ä¸ªå­—ç¬¦åˆ›å»ºspan
        for (let charIndex = 0; charIndex < wordText.length; charIndex++) {
          const char = wordText[charIndex]
          
          if (char === ' ') {
            html += `<span class="karaoke-char is-space" data-word="${i}" data-char="${charIndex}">&#8203;</span>`
          } else {
            html += `<span class="karaoke-char" data-word="${i}" data-char="${charIndex}">${char}</span>`
          }
        }
        
        // åœ¨å•è¯ä¹‹é—´æ·»åŠ ç©ºæ ¼ï¼ˆå¯¹è‹±æ–‡æ­Œå¾ˆé‡è¦ï¼‰
        if (i < words.length - 1 && !isChinese(wordText)) {
          html += '<span class="karaoke-char is-space">&#8203;</span>'
        }
      }
      
      // åªåœ¨HTMLçœŸæ­£å‘ç”Ÿå˜åŒ–æ—¶æ‰æ›´æ–°DOM
      if (lastRenderedHTML !== html) {
        currentLyric.innerHTML = html
        currentLyric.classList.add('active-line')
        container.classList.add('lyric-change')
        setTimeout(() => container.classList.remove('lyric-change'), 300)
        lastRenderedHTML = html
        isDOMReady = true
        
        // é‡ç½®ç¼“å­˜ï¼Œå› ä¸ºDOMç»“æ„å·²æ”¹å˜
        cachedCharElements = null
        karaokeUpdateCache.clear()
      }
    }

    // æ›´æ–°å¡æ‹‰OKè¿›åº¦ï¼ˆæåº¦ä¼˜åŒ–ç‰ˆæœ¬ï¼‰
    function updateKaraokeProgress(lyricLine, currentTime) {
      if (!isDOMReady) return
      
      const words = lyricLine.words || []
      const lineStartTime = lyricLine.time
      
      // ç¼“å­˜å­—ç¬¦å…ƒç´ ï¼Œé¿å…é‡å¤æŸ¥è¯¢DOM
      if (!cachedCharElements || currentLyricIndex !== lastProcessedWordIndex) {
        cachedCharElements = currentLyric.querySelectorAll('.karaoke-char:not(.is-space)')
        lastProcessedWordIndex = currentLyricIndex
      }
      
      // åªå¤„ç†æ´»è·ƒå•è¯é™„è¿‘çš„å­—ç¬¦ï¼Œè€Œä¸æ˜¯å…¨éƒ¨
      let globalCharIndex = 0
      let hasActiveChar = false
      
      for (let wordIndex = 0; wordIndex < words.length && !hasActiveChar; wordIndex++) {
        const word = words[wordIndex]
        const wordText = word.word || word.text
        const wordAbsoluteStartTime = lineStartTime + word.startTime
        const wordAbsoluteEndTime = lineStartTime + word.endTime
        
        // è·³è¿‡è¿˜æ²¡å¼€å§‹æˆ–å·²ç»ç»“æŸå¾ˆä¹…çš„å•è¯
        if (currentTime < wordAbsoluteStartTime - 500 || currentTime > wordAbsoluteEndTime + 500) {
          globalCharIndex += wordText.replace(/ /g, '').length
          continue
        }
        
        for (let charIndex = 0; charIndex < wordText.length; charIndex++) {
          const char = wordText[charIndex]
          
          if (char !== ' ' && globalCharIndex < cachedCharElements.length) {
            // è®¡ç®—å­—ç¬¦çš„æ—¶é—´ï¼ˆç®€å•å¹³å‡åˆ†é…ï¼‰
            const charDuration = word.duration / wordText.length
            const charStartTime = wordAbsoluteStartTime + (charIndex * charDuration)
            const charEndTime = charStartTime + charDuration
            
            const element = cachedCharElements[globalCharIndex]
            const cacheKey = `${wordIndex}-${charIndex}`
            
            // è®¡ç®—æ–°çŠ¶æ€
            let newClassName = 'karaoke-char'
            let fillProgress = 0
            
            if (currentTime < charStartTime) {
              // è¿˜æœªå¼€å§‹
              newClassName = 'karaoke-char'
            } else if (currentTime >= charEndTime) {
              // å·²å”±å®Œ
              newClassName = 'karaoke-char sung'
              fillProgress = 100
            } else {
              // æ­£åœ¨å”±
              newClassName = 'karaoke-char singing'
              const elapsed = currentTime - charStartTime
              fillProgress = Math.min(100, (elapsed / charDuration) * 100)
              hasActiveChar = true
            }
            
            // ä½¿ç”¨ç¼“å­˜é¿å…é‡å¤æ›´æ–°
            const cachedState = karaokeUpdateCache.get(cacheKey)
            if (!cachedState || cachedState.className !== newClassName) {
              element.className = newClassName
              karaokeUpdateCache.set(cacheKey, { className: newClassName, fillProgress })
            }
            
            // åªä¸ºæ­£åœ¨å”±çš„å­—ç¬¦æ›´æ–°è¿›åº¦ï¼ˆå‡å°‘90%çš„CSSæ›´æ–°ï¼‰
            if (newClassName.includes('singing') && Math.abs(fillProgress - (cachedState?.fillProgress || 0)) > 5) {
              element.style.setProperty('--fill-progress', fillProgress + '%')
              karaokeUpdateCache.set(cacheKey, { className: newClassName, fillProgress })
            }
            
            globalCharIndex++
          }
        }
      }
    }

    // æ¸²æŸ“æ™®é€šæ­Œè¯
    function renderNormalLyric(text, lyricLine) {
      const isChineseText = isChinese(text)
      let displayText = text
      
      if (isChineseText) {
        // ä¸­æ–‡æ­Œæ›²å¤„ç†
        if (lyricLine.translation) {
          // æœ‰ç¿»è¯‘æ—¶æ˜¾ç¤ºåŸæ–‡ï¼Œç¿»è¯‘åœ¨ä¸‹ä¸€è¡Œ
          displayText = text
        }
      } else {
        // éä¸­æ–‡æ­Œæ›²å¤„ç†
        displayText = text
      }

      // æ›´æ–°æ˜¾ç¤ºæ–‡æœ¬
      if (currentLyric.textContent !== displayText) {
        currentLyric.textContent = displayText
        container.classList.add('lyric-change')
        setTimeout(() => container.classList.remove('lyric-change'), 500)
      }
    }

    // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
    document.addEventListener('DOMContentLoaded', init)
  </script>
</body>
</html>